---
title: "Introduction_to_settleR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction_to_settleR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction 
# Background and Motivation 
I had a need to convey combinations of sets and found the the usual method to do this, venn-diagrams or Euler plots too limiting. My research invovles identifying differentially expressed genes which involved looking large numbers of datasets which could be grouped any number of ways. I found [UpSet plots](https://github.com/hms-dbmi/UpSetR/) to offer a succint way to visualize these comparisons which is relatively intuitive to my audience. There is already an [UpSet package](https://cran.rstudio.com/web/packages/UpSetR/), however, I found it was not amenable to customization. In my experience, it is very difficult to write re-usable, modular code creating plots for anything besides one-off functions that will be used once, or at most a single context. 

# settleR: A simple and customizable package for creating UpSet plots 
I created the settleR package to to address the percieved challenges primarily for my own needs, but I hope that others may find it useful too. 
The goal of settleR is to:

1. Create a simple/modular framework for UpSet-like figures
2. Make creating figures as painless as possible 
3. Allow for arbitrary customization 


```{r setup}
library(settleR)
library(grid)

```
# Creating a basic plot 
```{r, out.width="50%"}
# Loads an example setlist 
gene_setlist <- 
  system.file('extdata','ex_gene_setlist.rds', package = 'settleR') %>% 
  readRDS(.)

# Creating the SettleR object
setobj <- SettleR(gene_setlist)

# Plotting to the device

```


## Adding color to the groups 
```{r}
col_map <- 
  system.file('extdata','ex_col_map.rds', package = 'settleR') %>% 
  readRDS(.)

```
## Adding boxes around specific groups 
```{r, eval=FALSE}
setLevels <- 
  system.file('extdata','ex_set_levels.rds', package = 'settleR') %>% 
  readRDS(.)

intersect_lvls <- get_reordered_intersect_lvls(gene_setlist,
                                               setLevels = setLevels,
                                               nIntersects = 15)

bm <- sets_to_matrix(gene_setlist) %>% 
  calc_set_overlaps(., setLevels = setLevels, 
                    intersectLevels = intersect_lvls) 
  
ul <- make_upset_plots(bm, col_map = col_map)
bound_boxes <- intersect_lvls[c(10:13)] %>% 
  box_intercepts_dims(ul$pmain, .)
pmain <- ul$pmain + 
  geom_rect(data=bound_boxes,aes(xmin=xmin, xmax=xmax, ymin=ymin,ymax=ymax), 
            inherit.aes = FALSE, 
            color='red', 
            fill=NA,
            size=1.5
  )

```
# Creating Venn Diagram
## Creating 3-venn diagram plots 
This is the code which I've used to make an visual represention of the overlap. It's modified from [StackExchange answer]{https://stackoverflow.com/questions/43963293/how-to-define-color-of-intersection-in-a-venn-diagram} 
```{r, eval=FALSE}
library(VennDiagram)
library(sp)
library(lefutils)
library(rgeos)


vp <- venn.diagram(d, alpha = 1, filename = NULL,
                   category.names=c("A", "B", "C"), scaled=FALSE, euler.d=FALSE)

ix <- sapply(vp, function(x) grepl("text", x$name, fixed = TRUE))
labs <- do.call(rbind.data.frame, lapply(vp[ix], `[`, c("x", "y", "label")))

# Tries to convert str to numbers. Those which 
# Are NA are letters
lab_positions <- labs[is.na(as.numeric(labs$label)),]
lab_positions$label <- c("1", "2", "3")


circles <- vp[4:6]
venn_polygons <- lapply(seq_along(circles), function(i){
  cur_circ <- circles[[i]]
  x <- cur_circ[['x']]
  y <- cur_circ[['y']]
  # I have no idea what the below line does. 
  p <- SpatialPolygons(list(Polygons(list(Polygon(cbind(x, y))), ID = i))) 
}) %>% setNames(., c("1", "2", "3"))

abc_overlap <- reduce(venn_polygons, gIntersection)
ab_overlap <- gIntersection(venn_polygons[[1]], venn_polygons[[2]]) %>% gDifference(., venn_polygons[[3]])
a_overlap <- gDifference(venn_polygons[[1]], venn_polygons[[2]]) %>% gDifference(., venn_polygons[[3]])



create_custom_annotation <- function(text, x=.25, y=1.05, size=18){
  text_annot <-  
    grobTree(textGrob(text,
                      x=x,
                      y=y,
                      hjust=0,
                      gp=gpar(col="black",
                              fontsize=size,
                              fontface="bold")))
  
  return(text_annot)
}
create_gg_venn <- function(venn_polygons, ip, lab_positions){
  
  intersect_area <- 
    ip@polygons[[1]]@Polygons[[1]]@coords %>% 
    as_tibble(.) %>% 
    setNames(., c('x', 'y'))
  
  circles_area <- 
    lapply(venn_polygons, function(x){
      x@polygons[[1]]@Polygons[[1]]@coords %>% 
        as_tibble(.) %>% 
        setNames(., c('x', 'y'))
    }) %>% 
    setNames(., c("1", "2", "3")) 
  
  plot_data <- rbind_named_df_list(circles_area, 'group')
  
  
  plt <-  ggplot() +
    geom_path(data=plot_data, aes(x=x, y=y, group=group)) + 
    geom_polygon(data=intersect_area, aes(x=x, y=y)) + 
    geom_text(data=lab_positions, 
              aes(x=x, y=y, label=label),
              size=8, 
              fontface='bold',
              nudge_y = -.02) +
    theme_void()
    
  
  # plt <- plt +theme(plot.margin=margin(0, 0, 0, 0), aspect.ratio = 1)
  plt <- plt +theme(plot.margin=margin(0, 0, 0, 0))
    
        

  
  return(plt)
  
}


venn_plots <- 
  list(a_overlap, ab_overlap, abc_overlap) %>% 
  lapply(., function(x){
    create_gg_venn(venn_polygons, x, lab_positions)
  })


annot_text_list <- c('A only', 'A & B overlap', 'A, B, & C overlap')







```

This has turned out to be much more involved than I had initially expected. I should add this functionality to settleR.

## Creating a Grid plot matching the Venn diagrams
```{r, eval=FALSE}

## Making the grids 
intersect_id <- factor(rep(paste0("intersect_", 1:3), 3))
set_names <- factor(rep(LETTERS[1:3], 3))
observed <- as.logical(c(1,1,1, 1,1,0, 1,0,0))



grid_data <- 
  data.frame(intersect_id,set_names,observed ) %>% 
  arrange(set_names, intersect_id)
grid_data$intersect_id <- factor(intersect_id)



grid_plts <-  
    rev(split(grid_data,grid_data$intersect_id)) %>% 
    lapply(., function(x){
      tmp_plt <- grid_dot_plot(x, dot_size = 10)
      tmp_plt <- tmp_plt + 
        theme(plot.margin = unit(c(0, 0, 0, 0), "pt"))

      tmp_plt$layers[[4]] <- NULL
      # tmp_plt <- get_panel(tmp_plt)
      return(tmp_plt)
      
    })




adjust <- .05
line_coords <- c(.5 - adjust, 1.5 + adjust)
grid_plts$intersect_2 <- grid_plts$intersect_2 + geom_vline(xintercept = line_coords)

grid_plts <- lapply(grid_plts, get_panel)

comb_plts <- lapply(seq_along(grid_plts), function(i){
  pl <- list(as_grob(venn_plots[[i]]), grid_plts[[i]])
  tmp_plt <-
    plot_grid(plotlist = pl,
              align = 'v',
              axis ='tb',
              ncol = 1,
              rel_heights = c(6, 4), rel_widths = c(1,1))
})



ggsave2('grid_venn_diagram.pdf', plot = plot_grid(plotlist = comb_plts, nrow = 1, labels = "AUTO", label_y = .5, label_x=0, label_size=24 ), height = 4.5, width = 9)
```

